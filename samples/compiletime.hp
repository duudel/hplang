// hplang - Compile time execution sample
// 2016-03-30

use standard;

string :: struct
{
    length : s64;
    data : *char;
}

AstNode :: struct
{
    type : AstKind;
    {
        AstUnExpr un;
        AstBinExpr bin;
    }
}

assert("".length == 0);
assert("".data == null);

my_vector :: struct
{
    x, y, z : float;
}

do_things :: (x, y, z : float) // maybe allow this?
{ x+y+z; }

print_value(value : my_vector)
{
    print("(%f,%f,%f)", value.x, value.y, value.z);
}

print_arg(format : string, index : s64, arg : $T)
{
    cases format[index]
    {
        '#' {
            print_value(arg);
        }
        * {
            terminate_with_error("print: invalid format specifier");
        }
    }
}

print_arg(format : string, index : s64, arg : s64)
{
    assert(format[index] in ['d', 'i']);
    print_value(arg);
}

print :: (format :: string, args :: **) // :: means format and args cannot be modified (const)
{
    arg := 0;
    for 0..format.length-1
    {
        if format[it] == '%'
        {
            it++;
            assert(format.length < index, "print: Unexpected end of format string");
            if (format[it] != '%')
            {
                print_arg(format, it, args[arg]);
                arg++;
                continue;
            }
        }
        print_char(format[it]);
    }
}

print("lol")                // print
print("%d", 10)             // print!s64
print("%s %d", "lol", 12)   // print!string!s64

#bake print_specific = print<args : s64, s64, string>;

main :: ()
{
    print("Hurray!");

    var1 : s64;
    var2 : bool;

    var1 = 15 + 2;
    var2 = false;

    print("Var 1 = %d", var1);
    print("Var 1 = %d", var2);
}

#exec main();

